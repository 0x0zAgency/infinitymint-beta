(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./deployments"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScriptTypes = exports.createDeploymentsTypes = void 0;
    const tslib_1 = require("tslib");
    const deployments_1 = require("./deployments");
    /**
     *
     * @returns
     */
    const createDeploymentsTypes = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        let classes = yield (0, deployments_1.loadDeploymentClasses)({
            name: 'example',
            network: {
                name: 'ganache',
            },
            version: {
                version: '1.0.,0',
            },
        });
        let typeScript = `//this file is auto-generated by the InfinityMint CLI
    //do not modify this file directly
    import { InfinityMintDeploymentScript, InfinityMintDeploymentParameters, InfinityMintDeploymentLocal, InfinityMintDeploymentLive, ValuesReturnType  } from '@app/interfaces';
    import { Dictionary } from '@app/helpers';
    import { InfinityMintDeployment } from '@app/deployments';
    import { Contract } from '@ethersproject/contracts';
    `;
        //do imports for classes
        classes.forEach((cls) => {
            let fileName = cls.getContractName().replace(/ /g, '').split('.')[0];
            fileName = fileName.charAt(0).toUpperCase() + fileName.slice(1);
            if (cls.isLibrary() || cls.isLink())
                return;
            typeScript += `import { ${fileName} as ${fileName}Contract } from '@typechain-types/index';\n`;
        });
        classes.forEach((cls) => {
            let fileName = cls.getContractName().replace(/ /g, '').split('.')[0];
            fileName = fileName.charAt(0).toUpperCase() + fileName.slice(1);
            typeScript += `
            export abstract class ${fileName}DeploymentClass extends InfinityMintDeployment {
                public getDeploymentScript<T extends ${fileName}DeployScript>(): T {
                    return this.deploymentScript as T;
                }

                ${!cls.isLink() && !cls.isLibrary()
                ? `
                
                /**
                 *  Returns a read only contract which you can use to read values on chain
                 *  @returns
                 */
                public get read(): ${fileName}Contract {
                    return super.getContract() as ${fileName}Contract;
                }
                
                /**
                 * Returns a signed contract which you can use to change values on chain. The signer is the current default signer. Call getSignedContract for more control on who is the signer!
                 * @returns
                 */
                public async write(): Promise<${fileName}Contract> {
                    return super.getSignedContract<${fileName}Contract>();
                }
                `
                : ''}
                ${cls.values
                ? `public get values(): ${fileName}OnChainValues {
                            return this.deploymentScript.values;
                        }`
                : ''}\n
            }\n
        `;
            if (!cls.isLibrary() && !cls.isLink()) {
                //add it to the InfinityMintDeployments
                typeScript += `declare module '@app/interfaces' {\n`;
                typeScript += `    export interface InfinityMintDeployments {\n`;
                typeScript += `     ${fileName}?: ${fileName}DeploymentClass;\n`;
                typeScript += `    }\n`;
                typeScript += `}\n\n`;
            }
            if (!cls.isLibrary() && !cls.isLink()) {
                //add it to the InfinityMintDeployments
                typeScript += `declare module '@app/interfaces' {\n`;
                typeScript += `    export interface InfinityMintLiveDeployments {\n`;
                typeScript += `     ${fileName}?: ${fileName}DeploymentLive_Facade;\n`;
                typeScript += `    }\n`;
                typeScript += `}\n\n`;
            }
            //add script parameters
            typeScript += `export interface ${fileName}DeploymentLive_Facade extends InfinityMintDeploymentLive {\n`;
            if (cls.getDeploymentScript().values)
                typeScript += `    values?: ${fileName}OnChainValues;\n`;
            typeScript += `}\n\n`;
            //add script parameters
            typeScript += `export interface ${fileName}ScriptParameters extends InfinityMintDeploymentParameters {\n`;
            typeScript += `    deployment?: ${fileName}DeploymentClass;\n`;
            typeScript += `    deployScript?: ${fileName}DeployScript;\n`;
            typeScript += `}\n\n`;
            //add deploy arg type
            typeScript += `export type ${fileName}DeployArgType = (params: ${fileName}ScriptParameters) => Promise<string[]> | string[];\n\n`;
            typeScript += `export interface ${fileName}DeployScript extends InfinityMintDeploymentScript {\n`;
            typeScript += `    setup?: (script: ${fileName}ScriptParameters) => Promise<void>;\n`;
            typeScript += `    cleanup?: (script: ${fileName}ScriptParameters) => Promise<void | string[]>;\n`;
            typeScript += `    update?: (script: ${fileName}ScriptParameters) => Promise<Contract | Contract[]>;\n`;
            typeScript += `    post?: (script: ${fileName}ScriptParameters) => Promise<void>;\n`;
            typeScript += `    deploy?: (script: ${fileName}ScriptParameters) => Promise<{
        contract: Contract | Contract[];
        localDeployment: InfinityMintDeploymentLocal;
    }>;\n`;
            typeScript += `    switch?: (script: ${fileName}ScriptParameters) => Promise<Contract | Contract[]>;\n`;
            typeScript += `    deployArgs?: string[] | ${fileName}DeployArgType\n;`;
            if (cls.getDeploymentScript().values)
                typeScript += `    values?: ${fileName}OnChainValues\n;`;
            typeScript += `}\n\n`;
            typeScript += `export const ${fileName}: ${fileName}DeployScript = ${JSON.stringify(cls.getDeploymentScript(), null, 4)};\n\n`;
            //do settings
            if (cls.getDeploymentScript().settings ||
                cls.getDeploymentScript().values ||
                cls.getDeploymentScript().config) {
                //convert settings to types
                let getTypes = (obj, useValuesReturnType = false) => {
                    let types = '';
                    let func = (obj) => {
                        Object.keys(obj).forEach((key) => {
                            if (typeof obj[key] === 'object') {
                                types += `${key}?: {\n`;
                                func(obj[key]);
                                types += `};\n`;
                            }
                            else if (typeof obj[key] === 'function') {
                                if (useValuesReturnType) {
                                    types += `${key}?: ValuesReturnType;\n`;
                                }
                                else {
                                    types += `${key}?: any;\n`;
                                }
                            }
                            else {
                                types += `${key}?: ${typeof obj[key]};\n`;
                            }
                        });
                    };
                    func(obj);
                    return types;
                };
                if (cls.getDeploymentScript().settings)
                    Object.keys(cls.getDeploymentScript().settings).forEach((key) => {
                        var _a;
                        if (typeof cls.getDeploymentScript().settings[key] ===
                            'object') {
                            //do erc721
                            typeScript += `declare module '@app/interfaces' {\n`;
                            typeScript += `    export interface InfinityMintProjectSettings${key === 'erc721'
                                ? key.toUpperCase()
                                : key.charAt(0).toUpperCase() +
                                    key.substring(1)}  {\n`;
                            typeScript += `        ${getTypes((_a = cls.getDeploymentScript().settings) === null || _a === void 0 ? void 0 : _a[key])}`;
                            typeScript += `    }\n`;
                            typeScript += `}\n\n`;
                        }
                        else {
                            typeScript += `declare module '@app/interfaces' {\n`;
                            typeScript += `    export interface InfinityMintProjectSettings {\n`;
                            typeScript += `        ${key}?: ${typeof cls.getDeploymentScript()
                                .settings[key]};\n`;
                            typeScript += `    }\n`;
                            typeScript += `}\n\n`;
                        }
                    });
                if (cls.getDeploymentScript().config) {
                    typeScript += `declare module '@app/interfaces' {\n`;
                    typeScript += `    export interface  InfinityMintConfigSettingsDeploy {\n`;
                    typeScript += `        ${getTypes(cls.getDeploymentScript().config)}`;
                    typeScript += `    }\n`;
                    typeScript += `}\n\n`;
                }
                if (cls.getDeploymentScript().values) {
                    typeScript += `declare module '@app/interfaces' {\n`;
                    typeScript += `    export interface InfinityMintProjectSettingsValues{\n`;
                    typeScript += `        ${getTypes(cls.getDeploymentScript().values, true)}`;
                    typeScript += `    }\n`;
                    typeScript += `}\n\n`;
                    typeScript += `    export interface ${fileName}OnChainValues extends Dictionary<number | boolean | ValuesReturnType> {\n`;
                    typeScript += `        [key: string]: number | boolean | ValuesReturnType;\n`;
                    typeScript += `        ${getTypes(cls.getDeploymentScript().values, true)}`;
                    typeScript += `    }\n`;
                }
            }
        });
        return typeScript;
    });
    exports.createDeploymentsTypes = createDeploymentsTypes;
    const createScriptTypes = (scripts) => {
        //create a type defintion for the scripts
        let typeScript = `//this file is auto-generated by the InfinityMint CLI
    //do not modify this file directly
    import { InfinityMintScript, InfinityMintScriptArguments } from '@app/interfaces';
    `;
        scripts.forEach((script) => {
            var _a;
            let fileName = script.fileName.replace(/ /g, '').split('.')[0];
            fileName = fileName.charAt(0).toUpperCase() + fileName.slice(1);
            //arguments
            let args = '';
            (_a = script.arguments) === null || _a === void 0 ? void 0 : _a.forEach((arg) => {
                args += `${arg.name}: ${arg.type};\n`;
            });
            //add interface
            typeScript += `export interface ${fileName}Arguments extends InfinityMintScriptArguments {\n`;
            typeScript += `}\n\n`;
            //add type
            typeScript += `export interface ${fileName}Script extends InfinityMintScript {\n`;
            typeScript += `    arguments?: ${fileName}Arguments[];\n`;
            typeScript += `}\n\n`;
            typeScript += `export const ${fileName}: ${fileName}Script = ${JSON.stringify(script, null, 4)};\n\n`;
        });
        return typeScript;
    };
    exports.createScriptTypes = createScriptTypes;
});
//# sourceMappingURL=types.js.map